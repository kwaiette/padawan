{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy-slug-behavior\\lib\\behavior\\generateSlug.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/jagi:astronomy-slug-behavior/lib/behavior/generateSlug.js","filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy-slug-behavior\\lib\\behavior\\generateSlug.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","root":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","generatorOpts":{"filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy-slug-behavior\\lib\\behavior\\generateSlug.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jagi:astronomy-slug-behavior/lib/behavior/generateSlug.js"}},"code":"let isNull, each;\nmodule.watch(require(\"lodash\"), {\n  isNull(v) {\n    isNull = v;\n  },\n\n  each(v) {\n    each = v;\n  }\n\n}, 0);\nlet check;\nmodule.watch(require(\"./check\"), {\n  default(v) {\n    check = v;\n  }\n\n}, 1);\nlet diacriticsMap;\nmodule.watch(require(\"./diacriticsMap\"), {\n  default(v) {\n    diacriticsMap = v;\n  }\n\n}, 2);\n\nfunction generateSlug(doc) {\n  const Class = doc.constructor; // Check validity of the class for generating slug.\n\n  check.call(this, Class);\n  let value;\n\n  if (this.options.fieldName) {\n    // Get value of a field to make a slug from.\n    value = doc.get(this.options.fieldName);\n  } else if (this.options.helperName) {\n    // Generate value by a method to make a slug from.\n    value = doc[this.options.helperName]();\n  } // If a value is null then we can not create a slug.\n\n\n  if (isNull(value)) {\n    return;\n  } // Take the current value of the slug field.\n\n\n  const oldSlug = doc.get(this.options.slugFieldName); // If the current slug is not empty and we can not update, then we have to\n  // stop here.\n\n  if (oldSlug && !this.options.canUpdate) {\n    return;\n  } // GENERATE A NEW SLUG.\n  // Lower case.\n\n\n  let newSlug = value.toLowerCase(); // Remove diacriticts.\n\n  each(diacriticsMap, function (diacriticMap) {\n    newSlug = newSlug.replace(diacriticMap.letters, diacriticMap.base);\n  }); // Remove unsupported characters.\n\n  newSlug = newSlug.replace(/[^\\w\\s-]+/g, ''); // Trim.\n\n  newSlug = newSlug.replace(/^\\s+|\\s+$/g, ''); // Replace white characters with separator.\n\n  newSlug = newSlug.replace(/\\s+/g, this.options.separator); // If the \"unique\" option was set, then check whether there are any\n  // duplicates. If there is any document with the same slug, then we have to\n  // add number at the end of the slug.\n\n  if (newSlug !== oldSlug) {\n    // We have to check uniquness of the slug.\n    if (this.options.unique) {\n      const selector = {\n        [this.options.slugFieldName]: newSlug\n      };\n      const count = Class.find(selector, {\n        disableEvents: true\n      }).count();\n\n      if (count > 0) {\n        // Prepare the selector with a regular expression querying all the\n        // documents that contains our slug and ends with number.\n        const prefix = newSlug + this.options.separator;\n        const re = new RegExp('^' + prefix + '\\\\d+$');\n        selector[this.options.slugFieldName] = re; // Limit the amount of fields being fetched to only the slug field.\n\n        const options = {\n          fields: {\n            [this.options.slugFieldName]: 1\n          },\n          disableEvents: true\n        }; // Set the first number that will be added at the end of the slug to 2.\n\n        let index = 2; // Loop through all the documents with the same slug.\n\n        Class.find(selector, options).forEach(d => {\n          let dSlug = d.get(this.options.slugFieldName);\n          let dIndex = parseInt(dSlug.replace(prefix, ''), 10);\n\n          if (dIndex >= index) {\n            index = dIndex + 1;\n          }\n        });\n        newSlug = prefix + index;\n      }\n    } // Set a new slug.\n\n\n    doc.set(this.options.slugFieldName, newSlug);\n  }\n}\n\nmodule.exportDefault(generateSlug);","map":{"version":3,"sources":["packages/jagi:astronomy-slug-behavior/lib/behavior/generateSlug.js"],"names":["isNull","each","module","watch","require","v","check","default","diacriticsMap","generateSlug","doc","Class","constructor","call","value","options","fieldName","get","helperName","oldSlug","slugFieldName","canUpdate","newSlug","toLowerCase","diacriticMap","replace","letters","base","separator","unique","selector","count","find","disableEvents","prefix","re","RegExp","fields","index","forEach","d","dSlug","dIndex","parseInt","set","exportDefault"],"mappings":"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","sourcesContent":["import {\n  isNull,\n  each\n} from 'lodash';\nimport check from './check';\nimport diacriticsMap from './diacriticsMap';\n\nfunction generateSlug(doc) {\n  const Class = doc.constructor;\n\n  // Check validity of the class for generating slug.\n  check.call(this, Class);\n\n  let value;\n  if (this.options.fieldName) {\n    // Get value of a field to make a slug from.\n    value = doc.get(this.options.fieldName);\n  }\n  else if (this.options.helperName) {\n    // Generate value by a method to make a slug from.\n    value = doc[this.options.helperName]();\n  }\n\n  // If a value is null then we can not create a slug.\n  if (isNull(value)) {\n    return;\n  }\n\n  // Take the current value of the slug field.\n  const oldSlug = doc.get(this.options.slugFieldName);\n  // If the current slug is not empty and we can not update, then we have to\n  // stop here.\n  if (oldSlug && !this.options.canUpdate) {\n    return;\n  }\n\n  // GENERATE A NEW SLUG.\n  // Lower case.\n  let newSlug = value.toLowerCase();\n  // Remove diacriticts.\n  each(diacriticsMap, function(diacriticMap) {\n    newSlug = newSlug.replace(diacriticMap.letters, diacriticMap.base);\n  });\n  // Remove unsupported characters.\n  newSlug = newSlug.replace(/[^\\w\\s-]+/g, '');\n  // Trim.\n  newSlug = newSlug.replace(/^\\s+|\\s+$/g, '');\n  // Replace white characters with separator.\n  newSlug = newSlug.replace(/\\s+/g, this.options.separator);\n\n  // If the \"unique\" option was set, then check whether there are any\n  // duplicates. If there is any document with the same slug, then we have to\n  // add number at the end of the slug.\n  if (newSlug !== oldSlug) {\n    // We have to check uniquness of the slug.\n    if (this.options.unique) {\n      const selector = {\n        [this.options.slugFieldName]: newSlug\n      };\n      const count = Class.find(selector, {\n        disableEvents: true\n      }).count();\n\n      if (count > 0) {\n        // Prepare the selector with a regular expression querying all the\n        // documents that contains our slug and ends with number.\n        const prefix = newSlug + this.options.separator;\n        const re = new RegExp('^' + prefix + '\\\\d+$');\n        selector[this.options.slugFieldName] = re;\n        // Limit the amount of fields being fetched to only the slug field.\n        const options = {\n          fields: {\n            [this.options.slugFieldName]: 1\n          },\n          disableEvents: true\n        };\n        // Set the first number that will be added at the end of the slug to 2.\n        let index = 2;\n        // Loop through all the documents with the same slug.\n        Class.find(selector, options).forEach((d) => {\n          let dSlug = d.get(this.options.slugFieldName);\n          let dIndex = parseInt(dSlug.replace(prefix, ''), 10);\n          if (dIndex >= index) {\n            index = dIndex + 1;\n          }\n        });\n\n        newSlug = prefix + index;\n      }\n    }\n\n    // Set a new slug.\n    doc.set(this.options.slugFieldName, newSlug);\n  }\n}\n\nexport default generateSlug;"]},"sourceType":"script","hash":"1ac7cbf74e23697619ea6a40c30ede81c8673e3f"}
