{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js","filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","root":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","generatorOpts":{"filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js"}},"code":"var _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  \"default\": function (v) {\n    _each = v;\n  }\n}, 0);\n\nvar _intersection;\n\nmodule.watch(require(\"lodash/intersection\"), {\n  \"default\": function (v) {\n    _intersection = v;\n  }\n}, 1);\n\nvar _isNil;\n\nmodule.watch(require(\"lodash/isNil\"), {\n  \"default\": function (v) {\n    _isNil = v;\n  }\n}, 2);\nvar AstroClass;\nmodule.watch(require(\"../../../core/class\"), {\n  \"default\": function (v) {\n    AstroClass = v;\n  }\n}, 3);\nvar throwParseError;\nmodule.watch(require(\"../../core/utils/throw_parse_error\"), {\n  \"default\": function (v) {\n    throwParseError = v;\n  }\n}, 4);\nvar castNested;\nmodule.watch(require(\"../../fields/utils/castNested\"), {\n  \"default\": function (v) {\n    castNested = v;\n  }\n}, 5);\nvar isNestedFieldName;\nmodule.watch(require(\"../../fields/utils/isNestedFieldName\"), {\n  \"default\": function (v) {\n    isNestedFieldName = v;\n  }\n}, 6);\nvar traverse;\nmodule.watch(require(\"../../fields/utils/traverse\"), {\n  \"default\": function (v) {\n    traverse = v;\n  }\n}, 7);\nvar ObjectField;\nmodule.watch(require(\"../../fields/ObjectField\"), {\n  \"default\": function (v) {\n    ObjectField = v;\n  }\n}, 8);\nvar ListField;\nmodule.watch(require(\"../../fields/ListField\"), {\n  \"default\": function (v) {\n    ListField = v;\n  }\n}, 9);\nvar Validators;\nmodule.watch(require(\"../validators\"), {\n  \"default\": function (v) {\n    Validators = v;\n  }\n}, 10);\nvar ValidationError;\nmodule.watch(require(\"meteor/mdg:validation-error\"), {\n  ValidationError: function (v) {\n    ValidationError = v;\n  }\n}, 11);\n\nfunction documentValidate() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var doc = options.doc,\n      fields = options.fields,\n      _options$modified = options.modified,\n      modified = _options$modified === void 0 ? false : _options$modified,\n      _options$prefix = options.prefix,\n      prefix = _options$prefix === void 0 ? '' : _options$prefix,\n      _options$stopOnFirstE = options.stopOnFirstError,\n      stopOnFirstError = _options$stopOnFirstE === void 0 ? true : _options$stopOnFirstE,\n      _options$simulation = options.simulation,\n      simulation = _options$simulation === void 0 ? true : _options$simulation; // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  var Class = doc.constructor; // Cast nested fields.\n\n  castNested({\n    doc: doc,\n    options: {\n      clone: false\n    }\n  }); // Prepare array for storing errors list.\n\n  var errors = []; // Helper function for catching and collecting errors.\n\n  var catchValidationError = function (func) {\n    try {\n      func();\n    } catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        } // Otherwise we collect errors.\n        else {\n            _each(err.details, function (details) {\n              errors.push(details);\n            });\n          }\n      } // It it's not ValidationError, then we throw error again.\n      else {\n          throw err;\n        }\n    }\n  }; // If no fields were passed to validation, then we pick default validation\n  // order.\n\n\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  } // Validate only modified fields.\n\n\n  if (modified && Class.getCollection()) {\n    fields = _intersection(fields, doc.getModified());\n  }\n\n  _each(fields, function (name) {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, function (nestedDoc, nestedName, field) {\n        catchValidationError(function () {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: prefix + name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError: stopOnFirstError,\n            simulation: simulation\n          });\n        });\n      });\n      return;\n    }\n\n    var field = Class.getField(name); // Move to the next one if a field does not exist.\n\n    if (!field) {\n      return;\n    } // We do not validate transient fields.\n\n\n    if (field.transient) {\n      return;\n    } // Get value of the field.\n\n\n    var value = doc.get(name); // If a field is optional and value is undefined then we do not validate.\n\n    if (field.getOptional(doc) && _isNil(value)) {\n      return;\n    } // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n\n\n    catchValidationError(function () {\n      // First, execute type level validators.\n      field.validate({\n        doc: doc,\n        name: prefix + name,\n        nestedName: name,\n        value: value\n      }); // Get validators for a given field.\n\n      var validators = Class.getValidators(name);\n\n      _each(validators, function (_ref) {\n        var type = _ref.type,\n            param = _ref.param,\n            resolveParam = _ref.resolveParam,\n            message = _ref.message,\n            resolveError = _ref.resolveError;\n        // Get validation helper function.\n        var validationFunction = Validators[type]; // Execute single validator.\n\n        validationFunction({\n          doc: doc,\n          name: prefix + name,\n          nestedName: name,\n          value: value,\n          param: param,\n          resolveParam: resolveParam,\n          message: message,\n          resolveError: resolveError\n        });\n      });\n    }); // If it is the object field then validate it.\n\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(function () {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: prefix + field.name + '.',\n            stopOnFirstError: stopOnFirstError\n          });\n        });\n      }\n    } // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n        _each(value, function (element, index) {\n          if (element instanceof AstroClass) {\n            catchValidationError(function () {\n              documentValidate({\n                doc: element,\n                fields: element.constructor.getValidationOrder(),\n                prefix: prefix + field.name + '.' + index + '.',\n                stopOnFirstError: stopOnFirstError\n              });\n            });\n          }\n        });\n      }\n  }); // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n\n\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n}\n\n;\nmodule.exportDefault(documentValidate);","map":{"version":3,"sources":["packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js"],"names":["_each","module","watch","require","v","_intersection","_isNil","AstroClass","throwParseError","castNested","isNestedFieldName","traverse","ObjectField","ListField","Validators","ValidationError","documentValidate","options","doc","fields","modified","prefix","stopOnFirstError","simulation","Meteor","isServer","Class","constructor","clone","errors","catchValidationError","func","err","is","details","push","getValidationOrder","getCollection","getModified","name","nestedDoc","nestedName","field","substr","lastIndexOf","getField","transient","value","get","getOptional","validate","validators","getValidators","type","param","resolveParam","message","resolveError","validationFunction","isClass","element","index","length","exportDefault"],"mappings":"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","sourcesContent":["import _each from 'lodash/each';\nimport _intersection from 'lodash/intersection';\nimport _isNil from 'lodash/isNil';\nimport AstroClass from '../../../core/class';\nimport throwParseError from '../../core/utils/throw_parse_error';\nimport castNested from '../../fields/utils/castNested';\nimport isNestedFieldName from '../../fields/utils/isNestedFieldName';\nimport traverse from '../../fields/utils/traverse';\nimport ObjectField from '../../fields/ObjectField';\nimport ListField from '../../fields/ListField';\nimport Validators from '../validators';\nimport {\n  ValidationError\n}\nfrom 'meteor/mdg:validation-error';\n\nfunction documentValidate(options = {}) {\n  let {\n    doc,\n    fields,\n    modified = false,\n    prefix = '',\n    stopOnFirstError = true,\n    simulation = true\n  } = options;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  let Class = doc.constructor;\n\n  // Cast nested fields.\n  castNested({\n    doc,\n    options: {\n      clone: false\n    }\n  });\n\n  // Prepare array for storing errors list.\n  let errors = [];\n\n  // Helper function for catching and collecting errors.\n  const catchValidationError = (func) => {\n    try {\n      func();\n    }\n    catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        }\n        // Otherwise we collect errors.\n        else {\n          _each(err.details, (details) => {\n            errors.push(details);\n          });\n        }\n      }\n      // It it's not ValidationError, then we throw error again.\n      else {\n        throw err;\n      }\n    }\n  };\n\n  // If no fields were passed to validation, then we pick default validation\n  // order.\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  }\n\n  // Validate only modified fields.\n  if (modified && Class.getCollection()) {\n    fields = _intersection(fields, doc.getModified());\n  }\n\n  _each(fields, (name) => {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, (nestedDoc, nestedName, field) => {\n        catchValidationError(() => {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: prefix + name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError,\n            simulation\n          });\n        });\n      });\n      return;\n    }\n\n    let field = Class.getField(name);\n\n    // Move to the next one if a field does not exist.\n    if (!field) {\n      return;\n    }\n\n    // We do not validate transient fields.\n    if (field.transient) {\n      return;\n    }\n\n    // Get value of the field.\n    let value = doc.get(name);\n\n    // If a field is optional and value is undefined then we do not validate.\n    if (field.getOptional(doc) && _isNil(value)) {\n      return;\n    }\n\n    // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n    catchValidationError(() => {\n      // First, execute type level validators.\n      field.validate({\n        doc,\n        name: prefix + name,\n        nestedName: name,\n        value\n      });\n      // Get validators for a given field.\n      let validators = Class.getValidators(name);\n      _each(validators, ({\n        type,\n        param,\n        resolveParam,\n        message,\n        resolveError\n      }) => {\n        // Get validation helper function.\n        let validationFunction = Validators[type];\n        // Execute single validator.\n        validationFunction({\n          doc,\n          name: prefix + name,\n          nestedName: name,\n          value,\n          param,\n          resolveParam,\n          message,\n          resolveError\n        });\n      });\n    });\n\n    // If it is the object field then validate it.\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(() => {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: prefix + field.name + '.',\n            stopOnFirstError\n          });\n        });\n      }\n    }\n    // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n      _each(value, (element, index) => {\n        if (element instanceof AstroClass) {\n          catchValidationError(() => {\n            documentValidate({\n              doc: element,\n              fields: element.constructor.getValidationOrder(),\n              prefix: prefix + field.name + '.' + index + '.',\n              stopOnFirstError\n            });\n          });\n        }\n      });\n    }\n  });\n\n  // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n};\n\nexport default documentValidate;\n"]},"sourceType":"script","hash":"f1b79ae4d114c668b2117b6bf7e72b4b0f89de43"}
