{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js","filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","root":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","generatorOpts":{"filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\validators\\utils\\document_validate.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js"}},"code":"let _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 0);\n\nlet _intersection;\n\nmodule.watch(require(\"lodash/intersection\"), {\n  default(v) {\n    _intersection = v;\n  }\n\n}, 1);\n\nlet _isNil;\n\nmodule.watch(require(\"lodash/isNil\"), {\n  default(v) {\n    _isNil = v;\n  }\n\n}, 2);\nlet AstroClass;\nmodule.watch(require(\"../../../core/class\"), {\n  default(v) {\n    AstroClass = v;\n  }\n\n}, 3);\nlet throwParseError;\nmodule.watch(require(\"../../core/utils/throw_parse_error\"), {\n  default(v) {\n    throwParseError = v;\n  }\n\n}, 4);\nlet castNested;\nmodule.watch(require(\"../../fields/utils/castNested\"), {\n  default(v) {\n    castNested = v;\n  }\n\n}, 5);\nlet isNestedFieldName;\nmodule.watch(require(\"../../fields/utils/isNestedFieldName\"), {\n  default(v) {\n    isNestedFieldName = v;\n  }\n\n}, 6);\nlet traverse;\nmodule.watch(require(\"../../fields/utils/traverse\"), {\n  default(v) {\n    traverse = v;\n  }\n\n}, 7);\nlet ObjectField;\nmodule.watch(require(\"../../fields/ObjectField\"), {\n  default(v) {\n    ObjectField = v;\n  }\n\n}, 8);\nlet ListField;\nmodule.watch(require(\"../../fields/ListField\"), {\n  default(v) {\n    ListField = v;\n  }\n\n}, 9);\nlet Validators;\nmodule.watch(require(\"../validators\"), {\n  default(v) {\n    Validators = v;\n  }\n\n}, 10);\nlet ValidationError;\nmodule.watch(require(\"meteor/mdg:validation-error\"), {\n  ValidationError(v) {\n    ValidationError = v;\n  }\n\n}, 11);\n\nfunction documentValidate() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    doc,\n    fields,\n    modified = false,\n    prefix = '',\n    stopOnFirstError = true,\n    simulation = true\n  } = options; // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  let Class = doc.constructor; // Cast nested fields.\n\n  castNested({\n    doc,\n    options: {\n      clone: false\n    }\n  }); // Prepare array for storing errors list.\n\n  let errors = []; // Helper function for catching and collecting errors.\n\n  const catchValidationError = func => {\n    try {\n      func();\n    } catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        } // Otherwise we collect errors.\n        else {\n            _each(err.details, details => {\n              errors.push(details);\n            });\n          }\n      } // It it's not ValidationError, then we throw error again.\n      else {\n          throw err;\n        }\n    }\n  }; // If no fields were passed to validation, then we pick default validation\n  // order.\n\n\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  } // Validate only modified fields.\n\n\n  if (modified && Class.getCollection()) {\n    fields = _intersection(fields, doc.getModified());\n  }\n\n  _each(fields, name => {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, (nestedDoc, nestedName, field) => {\n        catchValidationError(() => {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: prefix + name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError,\n            simulation\n          });\n        });\n      });\n      return;\n    }\n\n    let field = Class.getField(name); // Move to the next one if a field does not exist.\n\n    if (!field) {\n      return;\n    } // We do not validate transient fields.\n\n\n    if (field.transient) {\n      return;\n    } // Get value of the field.\n\n\n    let value = doc.get(name); // If a field is optional and value is undefined then we do not validate.\n\n    if (field.getOptional(doc) && _isNil(value)) {\n      return;\n    } // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n\n\n    catchValidationError(() => {\n      // First, execute type level validators.\n      field.validate({\n        doc,\n        name: prefix + name,\n        nestedName: name,\n        value\n      }); // Get validators for a given field.\n\n      let validators = Class.getValidators(name);\n\n      _each(validators, (_ref) => {\n        let {\n          type,\n          param,\n          resolveParam,\n          message,\n          resolveError\n        } = _ref;\n        // Get validation helper function.\n        let validationFunction = Validators[type]; // Execute single validator.\n\n        validationFunction({\n          doc,\n          name: prefix + name,\n          nestedName: name,\n          value,\n          param,\n          resolveParam,\n          message,\n          resolveError\n        });\n      });\n    }); // If it is the object field then validate it.\n\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(() => {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: prefix + field.name + '.',\n            stopOnFirstError\n          });\n        });\n      }\n    } // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n        _each(value, (element, index) => {\n          if (element instanceof AstroClass) {\n            catchValidationError(() => {\n              documentValidate({\n                doc: element,\n                fields: element.constructor.getValidationOrder(),\n                prefix: prefix + field.name + '.' + index + '.',\n                stopOnFirstError\n              });\n            });\n          }\n        });\n      }\n  }); // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n\n\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n}\n\n;\nmodule.exportDefault(documentValidate);","map":{"version":3,"sources":["packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js"],"names":["_each","module","watch","require","default","v","_intersection","_isNil","AstroClass","throwParseError","castNested","isNestedFieldName","traverse","ObjectField","ListField","Validators","ValidationError","documentValidate","options","doc","fields","modified","prefix","stopOnFirstError","simulation","Meteor","isServer","Class","constructor","clone","errors","catchValidationError","func","err","is","details","push","getValidationOrder","getCollection","getModified","name","nestedDoc","nestedName","field","substr","lastIndexOf","getField","transient","value","get","getOptional","validate","validators","getValidators","type","param","resolveParam","message","resolveError","validationFunction","isClass","element","index","length","exportDefault"],"mappings":"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","sourcesContent":["import _each from 'lodash/each';\nimport _intersection from 'lodash/intersection';\nimport _isNil from 'lodash/isNil';\nimport AstroClass from '../../../core/class';\nimport throwParseError from '../../core/utils/throw_parse_error';\nimport castNested from '../../fields/utils/castNested';\nimport isNestedFieldName from '../../fields/utils/isNestedFieldName';\nimport traverse from '../../fields/utils/traverse';\nimport ObjectField from '../../fields/ObjectField';\nimport ListField from '../../fields/ListField';\nimport Validators from '../validators';\nimport {\n  ValidationError\n}\nfrom 'meteor/mdg:validation-error';\n\nfunction documentValidate(options = {}) {\n  let {\n    doc,\n    fields,\n    modified = false,\n    prefix = '',\n    stopOnFirstError = true,\n    simulation = true\n  } = options;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  let Class = doc.constructor;\n\n  // Cast nested fields.\n  castNested({\n    doc,\n    options: {\n      clone: false\n    }\n  });\n\n  // Prepare array for storing errors list.\n  let errors = [];\n\n  // Helper function for catching and collecting errors.\n  const catchValidationError = (func) => {\n    try {\n      func();\n    }\n    catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        }\n        // Otherwise we collect errors.\n        else {\n          _each(err.details, (details) => {\n            errors.push(details);\n          });\n        }\n      }\n      // It it's not ValidationError, then we throw error again.\n      else {\n        throw err;\n      }\n    }\n  };\n\n  // If no fields were passed to validation, then we pick default validation\n  // order.\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  }\n\n  // Validate only modified fields.\n  if (modified && Class.getCollection()) {\n    fields = _intersection(fields, doc.getModified());\n  }\n\n  _each(fields, (name) => {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, (nestedDoc, nestedName, field) => {\n        catchValidationError(() => {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: prefix + name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError,\n            simulation\n          });\n        });\n      });\n      return;\n    }\n\n    let field = Class.getField(name);\n\n    // Move to the next one if a field does not exist.\n    if (!field) {\n      return;\n    }\n\n    // We do not validate transient fields.\n    if (field.transient) {\n      return;\n    }\n\n    // Get value of the field.\n    let value = doc.get(name);\n\n    // If a field is optional and value is undefined then we do not validate.\n    if (field.getOptional(doc) && _isNil(value)) {\n      return;\n    }\n\n    // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n    catchValidationError(() => {\n      // First, execute type level validators.\n      field.validate({\n        doc,\n        name: prefix + name,\n        nestedName: name,\n        value\n      });\n      // Get validators for a given field.\n      let validators = Class.getValidators(name);\n      _each(validators, ({\n        type,\n        param,\n        resolveParam,\n        message,\n        resolveError\n      }) => {\n        // Get validation helper function.\n        let validationFunction = Validators[type];\n        // Execute single validator.\n        validationFunction({\n          doc,\n          name: prefix + name,\n          nestedName: name,\n          value,\n          param,\n          resolveParam,\n          message,\n          resolveError\n        });\n      });\n    });\n\n    // If it is the object field then validate it.\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(() => {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: prefix + field.name + '.',\n            stopOnFirstError\n          });\n        });\n      }\n    }\n    // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n      _each(value, (element, index) => {\n        if (element instanceof AstroClass) {\n          catchValidationError(() => {\n            documentValidate({\n              doc: element,\n              fields: element.constructor.getValidationOrder(),\n              prefix: prefix + field.name + '.' + index + '.',\n              stopOnFirstError\n            });\n          });\n        }\n      });\n    }\n  });\n\n  // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n};\n\nexport default documentValidate;\n"]},"sourceType":"script","hash":"fa7550eb8dd89742cc2ea82b57115140da8accf1"}
