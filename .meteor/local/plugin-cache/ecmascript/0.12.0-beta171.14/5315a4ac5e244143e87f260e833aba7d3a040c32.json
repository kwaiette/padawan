{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\storage\\utils\\getModifier.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining","pipelineOperator","throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"sourceFileName":"packages/jagi:astronomy/lib/modules/storage/utils/getModifier.js","filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\storage\\utils\\getModifier.js","passPerPreset":false,"envName":"development","cwd":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","root":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan","generatorOpts":{"filename":"C:\\Users\\wayne\\src\\kwaiette\\tmp\\padawan\\packages\\jagi:astronomy\\lib\\modules\\storage\\utils\\getModifier.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/jagi:astronomy/lib/modules/storage/utils/getModifier.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nconst module1 = module;\n\nlet _each;\n\nmodule1.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 0);\n\nlet _isNumber;\n\nmodule1.watch(require(\"lodash/isNumber\"), {\n  default(v) {\n    _isNumber = v;\n  }\n\n}, 1);\n\nlet _isPlainObject;\n\nmodule1.watch(require(\"lodash/isPlainObject\"), {\n  default(v) {\n    _isPlainObject = v;\n  }\n\n}, 2);\n\nlet _omitBy;\n\nmodule1.watch(require(\"lodash/omitBy\"), {\n  default(v) {\n    _omitBy = v;\n  }\n\n}, 3);\n\nlet _size;\n\nmodule1.watch(require(\"lodash/size\"), {\n  default(v) {\n    _size = v;\n  }\n\n}, 4);\nlet EJSON;\nmodule1.watch(require(\"meteor/ejson\"), {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 5);\nlet throwParseError;\nmodule1.watch(require(\"../../core/utils/throw_parse_error.js\"), {\n  default(v) {\n    throwParseError = v;\n  }\n\n}, 6);\nlet rawMany;\nmodule1.watch(require(\"../../fields/utils/rawMany\"), {\n  default(v) {\n    rawMany = v;\n  }\n\n}, 7);\nlet diff;\nmodule1.watch(require(\"./diff\"), {\n  default(v) {\n    diff = v;\n  }\n\n}, 8);\nconst handlers = {};\n\nhandlers.onObjectDiff = function (_ref) {\n  let {\n    oldDoc,\n    newDoc,\n    prefix,\n    result\n  } = _ref;\n  diff((0, _objectSpread2.default)({\n    oldDoc,\n    newDoc,\n    prefix,\n    result\n  }, handlers));\n};\n\nhandlers.onListDiff = function (_ref2) {\n  let {\n    oldList,\n    newList,\n    prefix,\n    result\n  } = _ref2;\n\n  // NOTE: We need check a new array size. If its length increased or stayed the\n  // same then all changes can be registered using the $set modifier. If an\n  // array length decreased, then we should slice it. However it may not be\n  // possible if some element has also changed. In such situation we have to\n  // override entire array.\n  // Array length decreased.\n  if (newList.length < oldList.length) {\n    // Due to an error in MiniMongo it's not possible to apply $push modifier\n    // with the $slice operator set to positive number. That's why we have to\n    // override entire array when it was shrinked.\n    result.$set[prefix] = newList;\n  } // Array length increased or stayed the same.\n  else if (newList.length >= oldList.length) {\n      let modified = false; // Compare up to number of elements in the new list.\n\n      _each(newList, (newElement, index) => {\n        const arrayPrefix = \"\".concat(prefix, \".\").concat(index);\n        const oldElement = oldList[index]; // When iterating over elements up to old array length.\n\n        if (index < oldList.length) {\n          if (!EJSON.equals(oldElement, newElement)) {\n            modified = true; // If both array elements are object, then we perform diff.\n\n            if (_isPlainObject(oldElement) && _isPlainObject(newElement)) {\n              // Get a difference between elements.\n              diff((0, _objectSpread2.default)({\n                oldDoc: oldElement,\n                newDoc: newElement,\n                prefix: arrayPrefix,\n                result\n              }, handlers));\n            } else {\n              result.$set[arrayPrefix] = newElement;\n            }\n          }\n        } // When iterating over newly added array elements.\n        else {\n            // Elements up to the old array length were modified, so we can not\n            // use the $push operator in conjunction with the $set operator.\n            if (modified) {\n              // If both array elements are object, then we perform diff.\n              if (_isPlainObject(oldElement) && _isPlainObject(newElement)) {\n                // Get a difference between elements.\n                diff((0, _objectSpread2.default)({\n                  oldDoc: oldElement,\n                  newDoc: newElement,\n                  prefix: arrayPrefix,\n                  result\n                }, handlers));\n              } else {\n                result.$set[arrayPrefix] = newElement;\n              }\n            } // Elements up to the old array length were not modified, so if there\n            // is any new array element added, we can insert it with the $push\n            // operator.\n            else {\n                // We have to check if there is only one element being pushed or\n                // more. If there is only one element then we use\n                // $push[prefix]: element\n                if (newList.length - oldList.length === 1) {\n                  result.$push[prefix] = newElement;\n                } // If there are more elements we have to use\n                // $push: { [prefix]: { $each: elements } }\n                else {\n                    result.$push[prefix] = {\n                      $each: newList.slice(index)\n                    }; // We have to break each loop here. We don't need to check any\n                    // more elements.\n\n                    return false;\n                  }\n              }\n          }\n      });\n    }\n};\n\nhandlers.onScalarDiff = function (_ref3) {\n  let {\n    oldValue,\n    newValue,\n    prefix,\n    result\n  } = _ref3;\n\n  if (newValue !== undefined) {\n    if (_isNumber(oldValue) && _isNumber(newValue)) {\n      result.$inc[prefix] = newValue - oldValue;\n    } else {\n      result.$set[prefix] = newValue;\n    }\n  } else {\n    result.$unset[prefix] = '';\n  }\n};\n\nconst getModifier = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    doc: newDoc,\n    transient = false,\n    immutable = false,\n    fields,\n    oldDoc\n  } = options;\n  const Class = newDoc.constructor;\n  const opts = {\n    defaults: false\n  };\n\n  if (!oldDoc) {\n    oldDoc = Class.findOne(newDoc._id, opts);\n  }\n\n  if (!oldDoc) {\n    oldDoc = new Class({}, opts);\n  } // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n\n\n  if (!oldDoc) {\n    throwParseError([{\n      'module': 'storage'\n    }, {\n      'utility': 'getModified'\n    }, \"Can not get a document before modifications. You are not subscribed \" + \"to the publication publishing a \\\"\".concat(Class.getName(), \"\\\" document with \") + \"the id \\\"\".concat(newDoc._id, \"\\\" or you have modified the \\\"_id\\\" field\")]);\n  } // If there are not fields specified, then get all of them.\n\n\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  const result = {\n    $set: {},\n    $inc: {},\n    $unset: {},\n    $push: {}\n  };\n  diff((0, _objectSpread2.default)({\n    // Get raw data from the docs.\n    oldDoc: rawMany(oldDoc, fields, {\n      transient,\n      immutable,\n      undefined: false\n    }),\n    newDoc: rawMany(newDoc, fields, {\n      transient,\n      immutable,\n      undefined: false\n    }),\n    result\n  }, handlers)); // Return only non empty modifiers.\n\n  return _omitBy(result, modifier => {\n    return _size(modifier) === 0;\n  });\n};\n\nmodule1.exportDefault(getModifier);","map":{"version":3,"sources":["packages/jagi:astronomy/lib/modules/storage/utils/getModifier.js"],"names":["module1","module","_each","watch","require","default","v","_isNumber","_isPlainObject","_omitBy","_size","EJSON","throwParseError","rawMany","diff","handlers","onObjectDiff","oldDoc","newDoc","prefix","result","onListDiff","oldList","newList","length","$set","modified","newElement","index","arrayPrefix","oldElement","equals","$push","$each","slice","onScalarDiff","oldValue","newValue","undefined","$inc","$unset","getModifier","options","doc","transient","immutable","fields","Class","constructor","opts","defaults","findOne","_id","getName","getFieldsNames","modifier","exportDefault"],"mappings":"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","sourcesContent":["import _each from 'lodash/each';\nimport _isNumber from 'lodash/isNumber';\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _omitBy from 'lodash/omitBy';\nimport _size from 'lodash/size';\nimport { EJSON } from 'meteor/ejson';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\nimport rawMany from '../../fields/utils/rawMany';\nimport diff from './diff';\n\nconst handlers = {};\n\nhandlers.onObjectDiff = function({oldDoc, newDoc, prefix, result}) {\n  diff({\n    oldDoc,\n    newDoc,\n    prefix,\n    result,\n    ...handlers\n  });\n};\n\nhandlers.onListDiff = function({oldList, newList, prefix, result}) {\n  // NOTE: We need check a new array size. If its length increased or stayed the\n  // same then all changes can be registered using the $set modifier. If an\n  // array length decreased, then we should slice it. However it may not be\n  // possible if some element has also changed. In such situation we have to\n  // override entire array.\n\n  // Array length decreased.\n  if (newList.length < oldList.length) {\n    // Due to an error in MiniMongo it's not possible to apply $push modifier\n    // with the $slice operator set to positive number. That's why we have to\n    // override entire array when it was shrinked.\n    result.$set[prefix] = newList;\n  }\n  // Array length increased or stayed the same.\n  else if (newList.length >= oldList.length) {\n    let modified = false;\n    // Compare up to number of elements in the new list.\n    _each(newList, (newElement, index) => {\n      const arrayPrefix = `${prefix}.${index}`;\n      const oldElement = oldList[index];\n      // When iterating over elements up to old array length.\n      if (index < oldList.length) {\n        if (!EJSON.equals(oldElement, newElement)) {\n          modified = true;\n          // If both array elements are object, then we perform diff.\n          if (_isPlainObject(oldElement) && _isPlainObject(newElement)) {\n            // Get a difference between elements.\n            diff({\n              oldDoc: oldElement,\n              newDoc: newElement,\n              prefix: arrayPrefix,\n              result,\n              ...handlers\n            });\n          }\n          else {\n            result.$set[arrayPrefix] = newElement;\n          }\n        }\n      }\n      // When iterating over newly added array elements.\n      else {\n        // Elements up to the old array length were modified, so we can not\n        // use the $push operator in conjunction with the $set operator.\n        if (modified) {\n          // If both array elements are object, then we perform diff.\n          if (_isPlainObject(oldElement) && _isPlainObject(newElement)) {\n            // Get a difference between elements.\n            diff({\n              oldDoc: oldElement,\n              newDoc: newElement,\n              prefix: arrayPrefix,\n              result,\n              ...handlers\n            });\n          }\n          else {\n            result.$set[arrayPrefix] = newElement;\n          }\n        }\n        // Elements up to the old array length were not modified, so if there\n        // is any new array element added, we can insert it with the $push\n        // operator.\n        else {\n          // We have to check if there is only one element being pushed or\n          // more. If there is only one element then we use\n          // $push[prefix]: element\n          if (newList.length - oldList.length === 1) {\n            result.$push[prefix] = newElement;\n          }\n          // If there are more elements we have to use\n          // $push: { [prefix]: { $each: elements } }\n          else {\n            result.$push[prefix] = {\n              $each: newList.slice(index)\n            };\n            // We have to break each loop here. We don't need to check any\n            // more elements.\n            return false;\n          }\n        }\n      }\n    });\n  }\n};\n\nhandlers.onScalarDiff = function({oldValue, newValue, prefix, result}) {\n  if (newValue !== undefined) {\n    if (_isNumber(oldValue) && _isNumber(newValue)) {\n      result.$inc[prefix] = newValue - oldValue;\n    }\n    else {\n      result.$set[prefix] = newValue;\n    }\n  }\n  else {\n    result.$unset[prefix] = '';\n  }\n};\n\nconst getModifier = function(options = {}) {\n  let {\n    doc: newDoc,\n    transient = false,\n    immutable = false,\n    fields,\n    oldDoc\n  } = options;\n\n  const Class = newDoc.constructor;\n  const opts = {\n    defaults: false\n  };\n  if (!oldDoc) {\n    oldDoc = Class.findOne(newDoc._id, opts);\n  }\n  if (!oldDoc) {\n    oldDoc = new Class({}, opts);\n  }\n\n  // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n  if (!oldDoc) {\n    throwParseError([{\n        'module': 'storage'\n      }, {\n        'utility': 'getModified'\n      },\n      `Can not get a document before modifications. You are not subscribed ` +\n      `to the publication publishing a \"${Class.getName()}\" document with ` +\n      `the id \"${newDoc._id}\" or you have modified the \"_id\" field`\n    ]);\n  }\n\n  // If there are not fields specified, then get all of them.\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  const result = {\n    $set: {},\n    $inc: {},\n    $unset: {},\n    $push: {}\n  };\n  diff({\n    // Get raw data from the docs.\n    oldDoc: rawMany(oldDoc, fields, {\n      transient,\n      immutable,\n      undefined: false\n    }),\n    newDoc: rawMany(newDoc, fields, {\n      transient,\n      immutable,\n      undefined: false\n    }),\n    result,\n    ...handlers\n  });\n\n  // Return only non empty modifiers.\n  return _omitBy(result, (modifier) => {\n    return _size(modifier) === 0;\n  });\n};\n\nexport default getModifier;"]},"sourceType":"script","hash":"5315a4ac5e244143e87f260e833aba7d3a040c32"}
